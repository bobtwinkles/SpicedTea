package tk.sirtwinkles.spicedtea.components;

import java.util.LinkedList;

import com.badlogic.gdx.utils.OrderedMap;

import tk.sirtwinkles.spicedtea.GameSpicedTea;
import tk.sirtwinkles.spicedtea.state.PlayingState;
import tk.sirtwinkles.spicedtea.world.Direction;
import tk.sirtwinkles.spicedtea.world.Level;
import tk.sirtwinkles.spicedtea.world.Point;
import tk.sirtwinkles.spicedtea.world.util.Pather;
import static tk.sirtwinkles.spicedtea.MathUtils.random;

public class AIDriverComponent extends Component {

	public AIDriverComponent(OrderedMap<String, Object> config) {
		super(config);
		// TODO Auto-generated constructor stub
	}

	@Override
	public void update(GameSpicedTea game, PlayingState play) {
		// Random movement
		MoverComponent mc = (MoverComponent) owner.getComponent("mover");
		if (!mc.hasQueuedMoves()) {
			Level l = play.getWorld().getCurrent();
			PositionComponent pc = (PositionComponent) owner
					.getComponent("position");
			int rx = random.nextInt(5) - 2 + ;
			int ry = random.nextInt(5) - 2;

			Point start = Point.getPoint(pc.x, pc.y);
			Point end = Point.getPoint(rx, ry);
			LinkedList<Point> p = Pather.path(play.getWorld().getCurrent(),
					null, start, end, this.owner);
			if (p != null) {
				mc.reset();
				p.addFirst(start);
				while (!p.isEmpty()) {
					Point curr = p.remove();
					Point next = p.peek();
					if (next != null) {
						int xDelta = curr.x - next.x;
						int yDelta = curr.y - next.y;
						if (xDelta == -1) {
							mc.add(Direction.E);
						} else if (xDelta == 1) {
							mc.add(Direction.W);
						} else if (yDelta == -1) {
							mc.add(Direction.S);
						} else if (yDelta == 1) {
							mc.add(Direction.N);
						}
					}
					Point.free(curr);
				}
			} else {
				Point.free(start);
			}
			// Start freed in loop
			Point.free(end);
		}
	}

	@Override
	public void destroy(GameSpicedTea game, PlayingState play) {
		// TODO Auto-generated method stub

	}

}
