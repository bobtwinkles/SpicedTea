package tk.sirtwinkles.spicedtea.components;

import java.util.LinkedList;
import java.util.Queue;

import tk.sirtwinkles.spicedtea.GameSpicedTea;
import tk.sirtwinkles.spicedtea.state.PlayingState;
import tk.sirtwinkles.spicedtea.world.Direction;
import tk.sirtwinkles.spicedtea.world.Level;
import tk.sirtwinkles.spicedtea.world.Point;
import tk.sirtwinkles.spicedtea.world.util.Pather;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.utils.OrderedMap;
import com.badlogic.gdx.utils.TimeUtils;

/**
 * Provides a common interface for moving entites
 * 
 * @author bob_twinkles
 * 
 */
public class MoverComponent extends Component {
	private LinkedList<Direction> movements;
	private Direction lastDirection;

	public MoverComponent(OrderedMap<String, Object> config) {
		super(config);
		this.movements = new LinkedList<Direction>();
		this.lastDirection = Direction.E;
	}

	@Override
	public void update(GameSpicedTea game, PlayingState play) {
		PositionComponent pc = (PositionComponent) this.owner.getComponent("position");
		// Movement processing.
		if (!movements.isEmpty()) {
			Direction d = movements.remove();
			lastDirection = d;
			switch (d) {
			case N:
				tryMove(pc.x, pc.y - 1, play.getWorld().getCurrent());
				break;
			case E:
				tryMove(pc.x + 1, pc.y, play.getWorld().getCurrent());
				break;
			case S:
				tryMove(pc.x, pc.y + 1, play.getWorld().getCurrent());
				break;
			case W:
				tryMove(pc.x - 1, pc.y, play.getWorld().getCurrent());
				break;
			}
		}
	}

	private boolean tryMove(int x, int y, Level in) {
		if (in.getTile(x, y).isPassable(owner, in)) {
			PositionComponent pc = (PositionComponent) owner
					.getComponent("position");
			pc.x = x;
			pc.y = y;
			in.onEntityMove(x, y, this.owner);
			return true;
		}

		return false;
	}

	@Override
	public void destroy(GameSpicedTea game, PlayingState play) {
		// Nothing to do here.
	}
	
	public Direction getLastDirection() {
		return lastDirection;
	}

	public void add(Direction n) {
		movements.add(n);
	}
	
	public void path(Point start, Point end) {
		goal.x = end.x; goal.y = end.y;
		p = Pather.path(play.getWorld().getCurrent(), null, start, end, this.owner);
		if (p != null) {
			mc.reset();
			p.addFirst(start);
			while (!p.isEmpty()) {
				Point curr = p.remove();
				Point next = p.peek();
				if (next != null) {
					int xDelta = curr.x - next.x;
					int yDelta = curr.y - next.y;
					if (xDelta == -1) {
						mc.add(Direction.E);
					} else if (xDelta == 1) {
						mc.add(Direction.W);
					} else if (yDelta == -1) {
						mc.add(Direction.S);
					} else if (yDelta == 1) {
						mc.add(Direction.N);
					}
				}
				Point.free(curr);
			}
		}
	}

	public void reset() {
		movements.clear();
	}

	public boolean hasQueuedMoves() {
		return !movements.isEmpty();
	}
}
