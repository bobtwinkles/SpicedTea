package tk.sirtwinkles.spicedtea.components;

import java.util.LinkedList;
import java.util.Queue;

import tk.sirtwinkles.spicedtea.GameSpicedTea;
import tk.sirtwinkles.spicedtea.state.PlayingState;
import tk.sirtwinkles.spicedtea.world.Direction;
import tk.sirtwinkles.spicedtea.world.Level;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.utils.OrderedMap;
import com.badlogic.gdx.utils.TimeUtils;

/**
 * Provides a common interface for moving entites
 * 
 * @author bob_twinkles
 * 
 */
public class MoverComponent extends Component {
	private LinkedList<Direction> movements;

	public MoverComponent(OrderedMap<String, Object> config) {
		super(config);
		this.movements = new LinkedList<Direction>();
	}

	@Override
	public void update(GameSpicedTea game, PlayingState play) {
		PositionComponent pc = (PositionComponent) this.owner.getComponent("position");
		// Movement processing.
		if (!movements.isEmpty()) {
			switch (movements.remove()) {
			case N:
				tryMove(pc.x, pc.y - 1, play.getWorld().getCurrent());
				break;
			case E:
				tryMove(pc.x + 1, pc.y, play.getWorld().getCurrent());
				break;
			case S:
				tryMove(pc.x, pc.y + 1, play.getWorld().getCurrent());
				break;
			case W:
				tryMove(pc.x - 1, pc.y, play.getWorld().getCurrent());
				break;
			}
		}
	}

	private boolean tryMove(int x, int y, Level in) {
		if (in.getTile(x, y).isPassable(owner, in)) {
			PositionComponent pc = (PositionComponent) owner
					.getComponent("position");
			pc.x = x;
			pc.y = y;
			in.onEntityMove(x, y, this.owner);
			return true;
		}

		return false;
	}

	@Override
	public void destroy(GameSpicedTea game, PlayingState play) {
		// Nothing to do here.
	}

	public void add(Direction n) {
		System.out.println(n);
		movements.add(n);
	}

	public void reset() {
		movements.clear();
	}
}
